#include <iostream>
using namespace std;

int N;
int dp[100001][3];

int main()
{
	// 우리 크기 2*N
	cin >> N;

	dp[1][0] = 1;
	dp[1][1] = 1;
	dp[1][2] = 1;

	for (int i = 2; i <= N; i++)
	{
		dp[i][0] = (dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2]) % 9901;
		dp[i][1] = (dp[i - 1][0] + dp[i - 1][2]) % 9901;
		dp[i][2] = (dp[i - 1][0] + dp[i - 1][1]) % 9901;
	}

	int answer = (dp[N][0] + dp[N][1] + dp[N][2]) % 9901;
	cout << answer;
	return 0;
}

/*
DP(다이나믹 프로그래밍) 문제
-> DP의 문제는 경우의 수를 생각하여 점화식을 도출하여 문제를 해결해야 하는데
이 문제의 경우는 갈피를 잡지 못하여 풀지 못하였다. 결국
https://yabmoons.tistory.com/137 의 문제풀이를 참고하여 코드를 작성하였다.

1. 첫 번째 줄에 사자를 배치할 수 있는 경우는 OX / XO / XX 로 3가지
2. 다음 줄에서 각 경우에 따라서 사자를 배치
- 두 번째 줄에 사자를 배치 안할 경우
- 두 번째 줄에 사자를 왼쪽에 배치했을 경우
- 두 번째 줄에 사자를 오른쪽에 배치했을 경우

=> 경우 수가 너무 많아져서 오버플로우가 발생할 수도 있다.
매번 값을 넣을때마다 9901을 나누어 주는 것으로 예방
*/