#include <iostream>
using namespace std;

int N;
int dp[1001][10];

int main()
{
	cin >> N;

	// 1의 자리는 각 경우의 수가 1개
	for (int i = 0; i < 10; i++)
		dp[1][i] = 1;

	// 2의 길이 경우부터 N의 길이까지
	for (int i = 2; i <= N; i++)
		// 1의 자리가 0~9일때
		for (int j = 0; j < 10; j++)
			for (int k = 0; k <= j; k++)
			{
				dp[i][j] = dp[i][j] + dp[i - 1][k];
				dp[i][j] %= 10007;
			}

	int total = 0;
	for (int i = 0; i < 10; i++)
		total += dp[N][i];
	cout << total % 10007;

	return 0;
}

/*
오르막의 수인 길이가 1000까지인데 1000 길이의 개수를 모두 구하는 것은
시간 초과 발생, 비효율적이다.
=> 패턴 찾기 시작

1의 자리
0, 1, 2, 3, 4, 5, 6, 7, 8, 9 : 10개

2의자리
00, 01, 02, 03, 04, 05, 06, 07, 08, 09
XX, 11, 12, 13, 14, 15, 16, 17, 18, 19
XX, XX, 22, 23, 24, 25, 26, 27, 28, 29
XX, XX, XX, 33, 34, 35, 36, 37, 38, 39

만약 A B 3 의 경우는
B : 0 -> A : 0
B : 1 -> A : 0, 1
B : 2 -> A : 0, 1, 2
B : 3 -> A : 0, 1, 2, 3

B가 3이라고 했을 때 2자리 수만 보면
A 3 이라면
A : 0, 1, 2, 3

=> 맨 뒤의 자리를 고정해 놓으면 앞의 경우의 수는 길이가 1 작으면서
같거나 작은 수들의 합들의 수가 된다.
*/
